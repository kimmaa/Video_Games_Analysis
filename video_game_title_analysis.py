# -*- coding: utf-8 -*-
"""Video_Game_title_Analysis

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IGszo9mY46fhXfbq_C3ailyAa1QW4C8h
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline

#from google.colab import files
#files.upload()

vgames = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/vgames2.csv')
vgames = vgames.drop ('Unnamed: 0', axis=1)
vgames

"""Sales 단위 - in millions"""

# 결측치 확인
vgames.isna().sum()

# 결측치 처리 / 중복 데이터 처리 
vgames.dropna(inplace = True)
vgames.drop_duplicates (inplace = True)
vgames

# 결측치 및 데이터 정리 확인
print (vgames.isna().sum())
print (vgames.info())
print (vgames.columns)
print (vgames.loc[10])

# 년도 데이터 정리 
vgames.iloc[:,2] 
np.sort(vgames['Year'])

# 년도 표현 방식 확인 및 통일 

print (len(vgames[vgames['Year'].apply(lambda x : len(str(int(x))) == 1)])) # 1자리 표현방식 개수
print (len(vgames[vgames['Year'].apply(lambda x : len(str(int(x))) == 2)])) # 2자리 표현방식 개수
def year_form(x):
    if len(str(int(x))) == 1:
        x = x+2000
    elif len(str(int(x))) == 2:
        if int(x) <= 22:
            x = x+2000
        else:
            x = x+1900
    return x

vgames['Year']= vgames['Year'].apply(year_form)
print (min(vgames['Year']))
np.sort(vgames['Year'])

print (len(vgames[vgames['Year'].apply(lambda x : len(str(int(x))) == 1)])) # 1자리 표현방식 개수
print (len(vgames[vgames['Year'].apply(lambda x : len(str(int(x))) == 2)])) # 2자리 표현방식 개수

# Year 컬럼 히스토그램으로 분포 확인
plt.hist(vgames['Year'], alpha= 0.4)
plt.title('Year histogram')
plt.show()

"""2010년 발매량이 정점 이후로 급격히 떨어지는 발매량 -> 콘솔 게임의 인기하락 
2015 이후 급격한 하락 -> 플랫폼의 대이동 예상
"""

# m, k --> numeric으로 바꾸기 (m=1000000 이 기준)
def value_to_float(x):
    if 'K' in x:
        x = x[:len(x)-1]
        x = float(x)*1000
    elif 'M' in x:
        x = x[:len(x)-1]
        x = float(x)*1000000
    else:
        x = float(x)*1000000
    return x
vgames['NA_Sales'] = vgames['NA_Sales'].apply(value_to_float)
vgames['EU_Sales'] = vgames['EU_Sales'].apply(value_to_float)
vgames['JP_Sales'] = vgames['JP_Sales'].apply(value_to_float)
vgames['Other_Sales'] = vgames['Other_Sales'].apply(value_to_float)

# total sales 로로 feature 만들기
vgames['Total_sales'] = vgames['NA_Sales']+ vgames['EU_Sales']+vgames['JP_Sales']+vgames['Other_Sales']
vgames

vgames['Total_sales'].describe

# 각 column별 히스토그램 확인 - Plaform, Genre, Publisher, Year

plt.figure(figsize=(25,15)) 
plt.subplot(221)
plt.hist(vgames['Platform'],alpha = 0.4, color='b')
plt.xticks(rotation=45)
plt.title('Platform histogram')
plt.subplot(222)
plt.hist(vgames['Genre'],alpha = 0.4, color='y')
plt.xticks(rotation=45)
plt.title('Genre histogram')
plt.subplot(223) 
plt.hist(vgames['Publisher'],alpha = 0.4, color='g')
plt.xticks(rotation=90)
plt.title('Publisher histogram')
plt.subplot(224) 
plt.hist(vgames['Year'],alpha = 0.2, color='r')
plt.xticks(rotation=45)
plt.title('Year histogram')

# plt.tight_layout()
plt.show()

# 각 Sales columns 별 히스트 그램 확인 - NA,EU,JP,Other
plt.figure(figsize=(20,15)) 

plt.subplot(231)
plt.hist(vgames['NA_Sales'], histtype = 'stepfilled', alpha = 0.4,color='m', label='National')
plt.legend(loc='upper right')
plt.title('NA Sales histogram')
plt.subplot(232)
plt.hist(vgames['EU_Sales'], histtype = 'stepfilled',alpha = 0.4,color='g',label= 'Europe')
plt.title('EU Sales histogram')

plt.subplot(233)
plt.hist(vgames['JP_Sales'], histtype = 'stepfilled',alpha = 0.4,color='r',label = 'Japan')
plt.title('Japan Sales histogram')
plt.subplot(234)
plt.hist(vgames['Other_Sales'], histtype = 'stepfilled',alpha = 0.4,color='c', label='Others')
plt.title('others Sales histogram')

plt.subplot(235)
plt.hist(vgames['Total_sales'], histtype = 'stepfilled',alpha = 0.2,color='y',label= 'Global')
plt.title('Total Sales histogram')

# plt.show()

vgames

# 지역에 따라서 선호하는 게임 장르가 다를까? --> 지역 PCA
from sklearn.preprocessing import StandardScaler, Normalizer
from sklearn.decomposition import PCA
vgames_sales = vgames.loc[:,'NA_Sales': 'Other_Sales']
vgames_genre = vgames['Genre']
print(vgames_sales, vgames_genre)

## k에 따라 inertia_(군집 내 거리제곱합의 합)이 어떻게 변하는 지 시각화 = k값 결정

from sklearn.cluster import KMeans 

def change_n_clusters(n_clusters, data):
    sum_of_squared_distance = []
    for n_cluster in n_clusters:
        kmeans = KMeans(n_clusters=n_cluster)
        kmeans.fit(vgames_sales)
        sum_of_squared_distance.append(kmeans.inertia_)
    plt.figure(1 , figsize = (12, 6))
    plt.plot(n_clusters , sum_of_squared_distance , 'o')
    plt.plot(n_clusters , sum_of_squared_distance , '--' , alpha = 0.7)
    plt.xlabel('Number of Clusters')
    plt.ylabel('Inertia')

n_clusters = [1, 2, 3, 4, 5]
change_n_clusters(n_clusters, vgames_sales)
# K값은 2 에서 distortion이 가장 심하므로 2.0개로 결정정

# 지역별 수치 표준화
scaler = StandardScaler()
vgames_sales = pd.DataFrame(scaler.fit_transform(vgames_sales), columns=['NA_Sales',  'EU_Sales',  'JP_Sales',  'Other_Sales'])
print (f"표준화된 지역 값:\n {vgames_sales}")
pca_sales = PCA(n_components=2)
extracted_pca_sales = pd.DataFrame(pca_sales.fit_transform(vgames_sales), columns=['PC1', 'PC2'])
print(extracted_pca_sales.head())
ratio = pca_sales.explained_variance_ratio_
ratio_sum = ratio.sum()

print (f"{ratio} \nPCA(2)의 분산 비율: {ratio_sum}")
sns.scatterplot(data=extracted_pca_sales, x='PC1', y='PC2', hue=vgames_genre);

from mpl_toolkits.mplot3d import Axes3D

# PCA(3) 의 값 도출
pca_sales3 = PCA(n_components=3)
extracted_pca_sales3 = pd.DataFrame(pca_sales3.fit_transform(vgames_sales), columns=['PC1', 'PC2', 'PC3'])
print(extracted_pca_sales3.head())
ratio3 = pca_sales3.explained_variance_ratio_
ratio_sum3 = ratio3.sum()

print (f"{ratio3} \nPCA(3)의 분산 비율: {ratio_sum3}")

fig = plt.figure(figsize= (10,10))
ax = fig.gca(projection='3d')
X = extracted_pca_sales3['PC1']
Y = extracted_pca_sales3['PC2']
Z = extracted_pca_sales3['PC3']
ax.set_xlabel('PC1')
ax.set_ylabel('PC2')
ax.set_zlabel('PC3')
ax.scatter(X,Y,Z, c='c')

plt.show();

# 지역에 따라서 선호하는 게임 장르가 다를까? --> 장르그룹별 나라평균을 anova테스트(F검정) 실행
import scipy.stats as stats
from scipy.stats import f_oneway
from statsmodels.formula.api import ols
from statsmodels.stats.anova import anova_lm
import warnings
g_NA_s = vgames.groupby('Genre')['NA_Sales'].mean()
g_EU_s = vgames.groupby('Genre')['EU_Sales'].mean()
g_JP_s = vgames.groupby('Genre')['JP_Sales'].mean()
g_OT_s = vgames.groupby('Genre')['Other_Sales'].mean()

genresales = pd.concat([g_NA_s,g_EU_s,g_JP_s,g_OT_s], axis=1)
print(genresales)

# Anova 테스트
na = np.array(g_NA_s)
eu = np.array(g_EU_s)
jp = np.array(g_JP_s)
ot = np.array(g_OT_s)

f_oneway(na, eu, jp, ot)
# 장르별 나라의 출하량의 F값이 높아서 나라별 출하량은 유의미한 상관관계가 없다. 즉 각 나라별 선호하는 장르가 다를것이다 라는 대안가설에 힘을 실어준다.

# 지역에 따라서 선호하는 게임 장르가 다를까? --> 장르그룹별 나라평균
g_TT_s = vgames.groupby('Genre')['Total_sales'].mean()
g_NA_s = vgames.groupby('Genre')['NA_Sales'].mean()
g_EU_s = vgames.groupby('Genre')['EU_Sales'].mean()
g_JP_s = vgames.groupby('Genre')['JP_Sales'].mean()
g_OT_s = vgames.groupby('Genre')['Other_Sales'].mean()

plt.figure(figsize=(20,15)) 

plt.subplot(221)
plt.plot(g_NA_s,  c='y', alpha = 0.6)
plt.xticks(rotation=45)
plt.ylim(10000, 550000)
plt.title('National Sales by Genre')
plt.subplot(222)
plt.plot(g_EU_s,  c='b', alpha = 0.6)
plt.xticks(rotation=45)
plt.ylim(10000, 550000)
plt.title('Europe Sales by Genre')
plt.subplot(223)
plt.plot(g_JP_s,  c='r', alpha = 0.6)
plt.xticks(rotation=45)
plt.ylim(10000, 550000)
plt.title('Japan Sales by Genre')
plt.subplot(224)
plt.plot(g_OT_s,  c='c', alpha = 0.6)
plt.xticks(rotation=45)
plt.ylim(10000, 550000)
plt.title('Otheres Sales by Genre')
plt.show()

plt.figure(figsize=(10,5)) 
plt.plot(g_TT_s,  c='g', alpha = 0.6)
plt.xticks(rotation=45)
plt.ylim(10000, 1000000)
plt.title('Total global Sales by Genre')
plt.show()

"""
전체 글로벌 그래프에 따르면 슈터 게임과 플래폼게임의 판매율이 가장 높고 그뒤를 레이싱 게임이 따른다. 
- 미국의 경우 플래폼과 슈터 장르가 높은 세일즈 량을 나타내고 그 뒤로 레이싱과 스포츠 장르의 판매율이 뒤를 따른다.
- 유럽의 경우 슈터와 플래폼게임이 우위를 차지하며 레이싱 게임의 판매율이 뒤를따르고
- 그외의 나라에서는 슈터와 레이싱 게임이 우위를 차지하며 플래폼 게임의 판매율이 뒤를 따른다
- 다만 일본의 경우 롤플레잉 게임이 우세한 장르로 슈터게임은 상당히 저조한 판매율을 기록하며 다른 나라들과 현저한 차이를 보인다."""

# 연도별 게임의 트렌드가 있을까? - Year 그룹핑 전체 판매율
# 연도별 비디오 게임의 총 출고량 Data Visualization
plt.plot(vgames.groupby('Year')['Total_sales'].sum()); 
plt.title('Total Sales by Year')
plt.show()
# 년도별 판매량의 그래프를 볼때, 2005년 ~ 2010년 전후로 급격한 상승세의 출하량을 보이며 유의미한 판매량을 보여줌. 
# 2015년 전후부터 급격한 하락세의 출하량을 보이며 유의미한 판매률을 보여줌 이는 비디오게임의 사양산업에 접어들었다는 것으로 보여짐. (ex. 스마트폰 게임의 활성화)

##연도별 비디오 게임 장르 트렌드
vgames['Year'].unique() 
vgames['Genre'].unique() 
vgames_Y_G = vgames.groupby(['Year', 'Genre'])
vgames_Y_G.describe()
#vgames_Y_G_df = vgames_Y_G.size()

#vgames_Y_G_df.plot(kind='barh', title = 'red vs white wine quality')

# Genre 라벨링
vgames.Genre.unique()
g_mapping = {'Action': 1, 'Adventure': 2, 'Misc': 3, 'Platform': 4, 'Sports': 5, 'Simulation':6,
           'Racing':7, 'Role-Playing': 8, 'Puzzle': 9, 'Strategy': 10, 'Fighting': 11, 'Shooter': 12}
vgames.Genre.map(g_mapping)
vgg = pd.DataFrame(vgames.Genre.map(g_mapping))
vgg
vg= pd.concat([vgames['Genre'], vgg], axis=1)
vg.columns = ["Genre", "Genre_label"]
vg

vyg = pd.concat ([vgames['Year'],vg], axis=1)
vyg

total_genre = vyg.pivot_table(values="Genre_label", index="Year", columns = "Genre", aggfunc='sum')
total_genre= total_genre.fillna(0)
total_genre

ax= total_genre.plot( )
ax.set_title("Total Genres by Year")

total_Year = total_genre.T
total_Year

# 1980~20120까지의 장르 분포
vgames_Genre_by_year= vyg.groupby("Genre")["Year"].sum().sort_values()
vgames_Genre_by_year.plot(kind="barh",fontsize=8);

# 1980~20120까지의 장르 분포
vgames_Genre_by_year= vyg.groupby("Genre")["Year"].sum().sort_values()
vgames_Genre_by_year.plot(kind="bar", alpha=0.4, fontsize=8)

plt.ylim(0, 7000000)
plt.grid()

plt.show()

genre_Y = pd.DataFrame(total_genre)
genre_Y = genre_Y.fillna(0)
genre_Y
#genre_Y['Total_genre_sum'] = genre_Y['Action']+ genre_Y['Adventure']+genre_Y['Fighting']+genre_Y['Misc'] + genre_Y['Platform']+genre_Y['Puzzle']+genre_Y['Racing']+genre_Y['Role-Playing']+ genre_Y['Shooter']+genre_Y['Simulation']+genre_Y['Sports']+genre_Y['Strategy']
genre_Y.describe()
#genre_Y.hist(bins=50, figsize=(15, 8))
#plt.show()

total_genre_Y = pd.DataFrame(total_genre)
total_genre_Y
total_genre_Y['Total_genre_sum'] = genre_Y['Action']+ genre_Y['Adventure']+genre_Y['Fighting']+genre_Y['Misc'] + genre_Y['Platform']+genre_Y['Puzzle']+genre_Y['Racing']+genre_Y['Role-Playing']+ genre_Y['Shooter']+genre_Y['Simulation']+genre_Y['Sports']+genre_Y['Strategy']
total_genre_Y.describe()

# 10년 단위로 묶기
total_Year['80yrs'] = total_Year[1980.0] + total_Year[1981.0] + total_Year[1982.0] + total_Year[1983.0] + total_Year[1984.0] + total_Year[1985.0] + total_Year[1986.0] + total_Year[1987.0] + total_Year[1988.0] + total_Year[1989.0]
total_Year['90yrs'] =  total_Year[1990.0] + total_Year[1991.0] + total_Year[1992.0] + total_Year[1993.0] + total_Year[1994.0] + total_Year[1995.0] + total_Year[1996.0] + total_Year[1997.0] + total_Year[1998.0] + total_Year[1999.0]
total_Year['00yrs'] =  total_Year[2000.0] + total_Year[2001.0] + total_Year[2002.0] + total_Year[2003.0] + total_Year[2004.0] + total_Year[2005.0] + total_Year[2006.0] + total_Year[2007.0] + total_Year[2008.0] + total_Year[2009.0]
total_Year['10yrs(inc.20)'] =  total_Year[2010.0] + total_Year[2011.0] + total_Year[2012.0] + total_Year[2013.0] + total_Year[2014.0] + total_Year[2015.0] + total_Year[2016.0] + total_Year[2017.0] + total_Year[2020.0]

total_years = total_Year.loc[:,'80yrs': '10yrs(inc.20)']
total_years

# 년대별 장르 분포 Data Visualization
ax = total_years.plot(kind='bar', stacked=True, alpha=0.7, rot=90, title="Genre's trend by Decades",
                      color =['slateblue', 'deeppink', 'salmon', 'steelblue'], figsize=(20,10))
for p in ax.patches:
  left, bottom, width, height = p.get_bbox().bounds
  ax.annotate("%.1f"%(height/100), xy=(left+width/2, bottom+height/2), ha='center', va='center')
plt.sca(ax)
plt.box(False)
plt.grid(True)

plt.show()

# 년대별 장르 분포 Data Visualization
fig = plt.figure(figsize=(9,9))
ax = total_years.plot(kind='bar', width= 1,alpha=0.7, rot=90, 
                      title="Genre's trend by Decades",color =['slateblue', 'deeppink', 'salmon', 'steelblue'], figsize=(20,10))
for p in ax.patches:
  left, bottom, width, height = p.get_bbox().bounds
  ax.annotate("%.1f"%(height/100), xy=(left+width/2, bottom+height/2), ha='center', va='center')
plt.grid(True)
plt.box()
plt.show()

#출고량이 높은 게임에 대한 analysis 및 Data Visualization
top_sales= vgames.copy()
top_sales.index = top_sales['Name']
top_sales
total_top10 = top_sales['Total_sales'].nlargest(10)
lates5_top10 = top_sales[top_sales['Year'] >= 2016]['Total_sales'].nlargest(10)
print(f"1980~2020까지 출고량이 높은 게임 top 10: \n{total_top10}")
print(f"최근 5년간 출고량이 높은 게임 top 10:\n{lates5_top10}")

total_top10 = pd.DataFrame(total_top10)
total_top10= total_top10.reset_index()
total_top10
print (f"전체 출고량 상위 10개: \n {total_top10}")

# 전체 출고량 상위 10개 ata Visualization
plt.figure(figsize=(12, 5))
sns.set_palette("Paired")
sns.barplot(data=total_top10, x='Name', y="Total_sales")
plt.xticks(rotation= 90)
plt.title('Video game sales TOP 10 from 1980 to 2020', fontsize=20)
plt.xlabel('Games Title',fontsize=16)
plt.ylabel('Sales',fontsize=16)

lates5_top10 = pd.DataFrame(lates5_top10)
lates5_top10= lates5_top10.reset_index()
lates5_top10

# 최근 5년간 출고량 상위 10개 Data Visualization
from numpy import median

plt.figure(figsize=(12, 5))
sns.barplot(data=lates5_top10, x='Name', y="Total_sales", estimator=median, palette="RdBu")
plt.xticks(rotation= 90)
plt.title('The latest TOP10 of Video game sales', fontsize=20)
plt.xlabel('Games Title', fontsize=16)
plt.ylabel('Sales',fontsize=16)
plt.xlim()

# 개인적인 분석 목표, 질문 >>> 어떤 게임 콘솔 기반의 어떤 게임을 만들면 시장성이 좋을까? 

# 1) 가장 많은 게임타이틀을 가지고 있는 Platform 
top_platform = vgames.copy()
# 플랫폼 시리즈상 크게 다르지 않은 플랫폼 기본 이름으로 변경 wii의 경우 플랫폼 플레이 방식이 달라 변경하지 않음
top_platform['Platform']=top_platform['Platform'].replace(['PS3', 'PS4', 'PS2'], ['PS', 'PS', 'PS'])
top_platform['Platform']=top_platform['Platform'].replace(['XB', 'X360', 'XOne'], ['Xbox', 'Xbox', 'Xbox'])

top_platform.Platform.unique()
top_platform

top_platform_trend = top_platform.groupby("Platform")["Total_sales"].count()
top_platform_trend = pd.DataFrame(top_platform_trend)
top_platform_trend = top_platform_trend.reset_index()
top_platform_trend=top_platform_trend.sort_values('Total_sales', ascending=False)
plt.figure(figsize=(12, 5))
sns.set_palette("coolwarm")
sns.barplot(x='Platform', y= 'Total_sales', data = top_platform_trend)
plt.title('The Number of Game Title by Platform from 1980 to 2020', fontsize=20)
plt.xlabel('Platform Type', fontsize=16)
plt.ylabel('The Number of Game Title',fontsize=16)

# 2-1) 가장 많은 게임 타이틀을 가지고 있는 플랫폼 play Station의 출시된 장르 분석
PS = top_platform[top_platform['Platform']=='PS']
PS.index = PS['Genre']
PSG= PS['Genre'].value_counts()
PSG = pd.DataFrame(PSG)
PSG = PSG.reset_index()
PSG

plt.figure(figsize=(12, 6))
sns.color_palette('RdBu')
sns.barplot(x='index', y= 'Genre', data = PSG)
plt.title('The Best released Genre of PlayStation', fontsize=20)
plt.xlabel('Genre', fontsize=16)
plt.ylabel('The Number of Released by Game Genre',fontsize=16)

# 2-2) 가장 많은 게임 타이틀을 가지고 있는 플랫폼 play Station의 판매량 장르 분석
PS_SG = PS.reset_index(drop=True) 
PS_SG = PS_SG[['Name','Genre','Total_sales']]
PS_SG = PS_SG.groupby("Genre")["Total_sales"].sum().sort_values(ascending=False)
PS_SG = pd.DataFrame(PS_SG)
PS_SG = PS_SG.reset_index()
PS_SG

plt.figure(figsize=(12, 6))
sns.color_palette('RdBu')
sns.barplot(x='Genre', y= 'Total_sales', data = PS_SG)
plt.title('The Best Sold Genre of Playstation', fontsize=20)
plt.xlabel('Genre', fontsize=16)
plt.ylabel('The Number of Sold Game by Genre',fontsize=16)

# 2-3) 가장 많은 게임 타이틀을 가지고 있는 플랫폼 play Station의 장르별 출시량과 판매량은 얼마나 관계가 있는가? - TT-test
PSG1 = PSG.sort_index()
PS_SG1 =PS_SG.sort_index()
PSG_SG = pd.concat([PSG1, PS_SG1], axis=1)
PSG_SG = PSG_SG.drop('index', axis=1)
PSG_SG.columns = ["Total_Count", "Genre", "Total_sales"]
sales = PSG_SG['Total_sales']
release = PSG_SG['Total_Count']
tt_pvalue = stats.ttest_ind(sales,release, equal_var=False).pvalue
tt_pvalue=tt_pvalue/2 # 단측검정
if tt_pvalue >= 0.05:
  print(' 장르별 출시량과 판매량의 평균은 차이가 나지 않는다.')
else:
  print(' 장르별 출시량과 판매량의 평균 유의미한 차이가 있다. 즉, 판매량과 출시량은 같은 비율이 아니다')

"""판매량과 출시량의 유의미한 차이를 인지.

2-4) 가장 많은 게임 타이틀을 가지고 있는 최근 5년간의 플랫폼은?

Play Station

2-5) 가장 많은 게임 타이틀을 가지고 있는 플랫폼 play Station의 최근 5년간 가장많이 출시한 장르는?
"""

# PS_G = PS.groupby('Genre')
PS_G = (PS['Year']>=2016).groupby(PS['Genre'])
PS_G5=PS_G.count()
#PS_G5 = np.array(PS_G5)
PS_G5 = pd.DataFrame(PS_G5)
PS_G5 = PS_G5.reset_index()
PS_G5.index = PS_G5['Genre']

PS_g_top5 = PS_G5['Year'].nlargest(5)
print(f"play Station의 최근 5년간 가장많이 출시한 장르 top 5:\n{PS_g_top5}")

"""2-6) 가장 많은 게임 타이틀을 가지고 있는 플랫폼 play Station의 최근 5년간 가장많이 판매된 장르 분석 시각화

"""

# 개인적인 분석 목표, 질문
PS5 = PS[PS['Year']>=2016]
PS5_sales = PS5['Total_sales'].nlargest(11)
PS5_sales_df = pd.DataFrame(PS5_sales)
PS5_sales_df = PS5_sales_df.reset_index()
PS5_sales_df
PS5_sales_grouped = PS5_sales_df['Total_sales'].groupby(PS5_sales_df['Genre'])
PS5_S = PS5_sales_grouped.sum()
PS5_S = PS5_S.sort_values(ascending=False)
print(f"최근 5년간 Playstation에서 가장 많이 팔린 장르 top 5:\n{PS5_S}")
PS5_SS = pd.DataFrame(PS5_S)
PS5_SS.reset_index()
PS5_SS.sum(axis=0)

shooter = round((10920000 / 24600000.0)*100, 3)
Sports = round((7200000.0/ 24600000.0)*100, 3)
Action = round((3740000.0/ 24600000.0)*100, 3)
RolePlaying = round((1560000.0/ 24600000.0)*100, 3)
Platform = round((1180000.0// 24600000.0)*100, 3)

## 데이터 준비
labels = ['shooter','Sports','Action','Role-Playing','Platform'] ## 라벨
frequency = [shooter,Sports,Action,RolePlaying,Platform] ## 빈도
 
fig = plt.figure(figsize=(8,8)) ## 캔버스 생성
fig.set_facecolor('white') ## 캔버스 배경색을 하얀색으로 설정
ax = fig.add_subplot() ## 프레임 생성
colors = sns.color_palette('RdBu',len(labels))
pie = ax.pie(frequency, ## 파이차트 출력
       startangle=90, ## 시작점을 90도(degree)로 지정
       counterclock=False, ## 시계 방향으로 그린다.
       colors = colors ## 색상 지정
       )
 


total = np.sum(frequency) ## 빈도수 합
 
threshold = 5 ## 상한선 비율
sum_pct = 0 ## 퍼센티지
 
bbox_props = dict(boxstyle='square',fc='w',ec='w',alpha=0) ## annotation 박스 스타일
 
## annotation 설정
config = dict(arrowprops=dict(arrowstyle='-'),bbox=bbox_props,va='center')
 
for i,l in enumerate(labels):
    ang1, ang2 = ax.patches[i].theta1, ax.patches[i].theta2 ## 파이의 시작 각도와 끝 각도
    center, r = ax.patches[i].center, ax.patches[i].r ## 원의 중심 좌표와 반지름길이
    
    if i < len(labels) - 1:
        sum_pct += float(f'{frequency[i]/total*100:.2f}')
        text = f'{frequency[i]/total*100:.2f}%'
    else: ## 마지막 파이 조각은 퍼센티지의 합이 100이 되도록 비율을 조절
        text = f'{100-sum_pct:.2f}%'
    
    ## 비율 상한선보다 작은 것들은 Annotation으로 만든다.
    if frequency[i]/total*100 < threshold:
        ang = (ang1+ang2)/2 ## 중심각
        x = np.cos(np.deg2rad(ang)) ## Annotation의 끝점에 해당하는 x좌표
        y = np.sin(np.deg2rad(ang)) ## Annotation의 끝점에 해당하는 y좌표
        
        ## x좌표가 양수이면 즉 y축을 중심으로 오른쪽에 있으면 왼쪽 정렬
        ## x좌표가 음수이면 즉 y축을 중심으로 왼쪽에 있으면 오른쪽 정렬
        horizontalalignment = {-1: "right", 1: "left"}[int(np.sign(x))]
        connectionstyle = "angle,angleA=0,angleB={}".format(ang) ## 시작점과 끝점 연결 스타일
        config["arrowprops"].update({"connectionstyle": connectionstyle}) ## 
        ax.annotate(text, xy=(x, y), xytext=(1.5*x, 1.2*y),
                    horizontalalignment=horizontalalignment, **config)
    else:
        x = (r/2)*np.cos(np.pi/180*((ang1+ang2)/2)) + center[0] ## 텍스트 x좌표
        y = (r/2)*np.sin(np.pi/180*((ang1+ang2)/2)) + center[1] ## 텍스트 y좌표
        ax.text(x,y,text,ha='center',va='center',fontsize=12)

plt.title('The Top 5 Genre of PlayStation', fontsize = 20)
plt.legend(pie[0],labels,loc='upper right') ## 범례 표시
plt.show()